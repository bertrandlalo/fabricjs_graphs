<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">

    <title>XqNode demo</title>

    <style>
        pre {
            margin-left: 15px !important
        }
    </style>
    <script src="assets/js/fabric.js"></script>
</head>
<body>
<!--<script async defer src="https://buttons.github.io/buttons.js"></script>-->


<div id="bd-wrapper">
    <h2>Fabric Nodes Tests</h2>

    <canvas id="c" width="600" height="500"></canvas>

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <script id="main">(function () {
        fabric.Object.prototype.transparentCorners = false;

        var canvas = this.__canvas = new fabric.Canvas('c', {
            backgroundColor: '#eee',
            HOVER_CURSOR: 'pointer'
        });

        canvas.selection = false;

        var all_nodes = {};

        fabric.Node = fabric.util.createClass(fabric.Group, {
            type: 'Node',

            initialize: function (options) {

                this.width = options.width;
                this.height = options.height;
                this.id = options.id;
                all_nodes[this.id] = this;
                $.extend(options,
                    {
                        originX: 'left',
                        originY: 'top',
                        subTargetCheck: true,
                        lockUniScaling: true,
                        hasRotatingPoint: false,
                        hoverCursor: 'default',
                        cornerSize: 4,


                    });

                this.callSuper('initialize', [], options);

                this.set('customAttribute', options.customAttribute || 'undefinedCustomAttribute');

                this.body = new fabric.   Rect({
                    name: 'body',
                    originX: 'left',
                    originY: 'top',
                    top: 0,
                    left: 0,
                    width: 150,
                    height: 150,
                    // top: -this.height / 2,
                    // left: -this.width / 2,
                    // width: this.width,
                    // height: this.height,
                    rx: 4,
                    ry: 4,
                    fill: options.fill || "#ddd",
                    stroke: '#444',
                    fillRule: "nonzero",
                    shadow: {color: 'rgba(0,0,0,0.3)', offsetX: 5, offsetY: 5, blur: 5}
                });
                // this._objects.push(this.body);

                // this.body.on('mouse:over', function(e) {
                //     // e.target should be the circle
                //     console.log(e.target);
                // });
                this.add(this.body);

                // this.getCoords();
                // this.addWithUpdate();

                this.hooks_data = [];
                this.hooks = [];
                this._hooks_by_id = {};


                this.define_hooks(options.hooks_data || []);
                console.log(this._objects);

                this.addWithUpdate();
                console.log(this._objects);

                // event handlers

                this.on('selected', function (options) {
                    // if (this.body.containsPoint(options.e))
                    //     console.log('AAAAA');
                    // console.log(e.target.top, e.target.left);
                    this.body.set('fill', '#fff');
                    console.log('selected');
                });

                this.on('deselected', function (options) {
                    // if (this.body.containsPoint(options.e))
                    //     console.log('AAAAA');
                    // console.log(e.target.top, e.target.left);
                    this.body.set('fill', '#ddd');
                    console.log('deselected');
                });

                this.on('moved', function (options) {
                    // if (this.body.containsPoint(options.e))
                    //     console.log('AAAAA');
                    // console.log(e.target.top, e.target.left);
                    console.log('moved');
                });

                this.on('mousedown', this.node_mouse_down);


                // this.set('dirty', true);
                this.setCoords();
                //
                this.setShadow({color: 'rgba(255,255,255,0.3)'});

                this.connect = function (hook_id, to_node) {
                    var hook = this.getHookById(hook_id);
                    hook.to_node = to_node;
                };

            },


            get_hook_center: function (hook_arg) {
                // Get center point, in absolute coords, of hook bullet.
                // hook_arg may be a hook or a hook_id

                var hook, bullet_center, radius, node_center;
                if (typeof hook_arg == "object") {
                    hook = hook_arg;
                } else {
                    hook = this.getHookById(hook_arg);
                }

                bullet_center = hook.bullet.getCenterPoint();
                node_center = this.getCenterPoint();
                radius = (hook.side == 'left' ? -hook.radius : hook.radius);
                return {
                    x: node_center.x + bullet_center.x + radius,
                    y: node_center.y + bullet_center.y
                };
            },


            define_hooks: function (hooks_data) {
                // this.hooks = hooks;
                this.max_hooks_positions = {top: 15, left: 15, right: 15, bottom: 15};
                for (let h = 0; h < hooks_data.length; h++) {
                    this.add_hook(hooks_data[h]);
                }
            },


            add_hook: function (hook_data) {
                this.hooks_data.push(hook_data);
                console.log(this);
                console.log(hook_data);
                hook = {
                    side: hook_data.side || 'right',
                    radius: hook_data.radius || 5,
                    caption: hook_data.caption || '',
                    fill: hook_data.fill || '#444',
                    out: hook_data.out || true,
                };

                if (hook.side == 'right') {
                    hook.x = this.body.left + this.body.width;
                    hook.y = this.body.top + this.max_hooks_positions[hook.side];
                    hook.caption_x = hook.x - 12;
                    hook.caption_y = hook.y;
                } else if (hook.side == 'left') {
                    hook.x = this.body.left;
                    hook.y = this.body.top + this.max_hooks_positions[hook.side]; // -this.body.height / 2 + this.max_hooks_positions[hook.side];
                    hook.caption_x = hook.x + 12;
                    hook.caption_y = hook.y;
                }
                // if (hook.side == 'right') {
                //     hook.x = this.body.width / 2;
                //     hook.y = -this.body.height / 2 + this.max_hooks_positions[hook.side];
                //     hook.caption_x = hook.x - 12;
                //     hook.caption_y = hook.y;
                // } else if (hook.side == 'left') {
                //     hook.x = -this.body.width / 2;
                //     hook.y = -this.body.height / 2 + this.max_hooks_positions[hook.side];
                //     hook.caption_x = hook.x + 12;
                //     hook.caption_y = hook.y;
                // }
                // Will see later
                // else if (hook.side == 'top') {
                //     hook.y = -this.height/2 + hook.radius;
                //     hook.x = -this.width / 2 + this.max_hooks_positions[hook.side];
                // }
                // else if (hook.side == 'bottom') {
                //     hook.y = this.height/2 + hook.radius;
                //     hook.x = -this.width / 2 + this.max_hooks_positions[hook.side];
                // }
                else {
                    throw "Hook side is erroneous: " + hook.side;
                }

                this.max_hooks_positions[hook.side] += 15;

                hook.bullet = new fabric.Circle({
                    node: this,
                    name: 'bullet',
                    type: 'hook-bullet',
                    hook: hook,
                    originX: 'center',
                    originY: 'center',
                    top: hook.y,
                    left: hook.x,
                    radius: hook.radius,
                    fill: hook.fill,
                    hoverCursor: 'pointer',
                    stroke: '#222',
                    strokeWidth: 1
                });

                // hook.bullet.setCoords();            // Don't know why, but without this, bullet.oCoords is null and fails in containtsPoint()
                // this._objects.push(hook.bullet);

                var text = new fabric.Text(hook.caption, {
                    name: 'hook-caption',
                    type: 'hook-caption',
                    fontFamily: 'Arial', fontSize: 10, fill: '#222', fontStyle: 'normal',
                    originX: 'center', originY: 'center',
                    top: hook.caption_y, left: hook.caption_x,
                    width: 20, height: 20
                });

                // this._objects.push(text);
                this.add(text);
                text.setCoords();

                this.add(hook.bullet);
                hook.bullet.setCoords();

                this.addWithUpdate();
                this.setCoords();

                this._hooks_by_id[hook_data.id] = hook;
                this.hooks.push(hook);

                console.log("add_hook: " + this._objects);
                console.log(this._hooks_by_id);
                // canvas.bringToFront(hook.bullet);
                // this.addWithUpdate();

            },


            getHookById: function (hook_id) {
                if (!this._hooks_by_id.hasOwnProperty(hook_id)) {
                    throw "Node has no hook with id " + hook_id;
                }
                return this._hooks_by_id[hook_id];
            },


            draw_links: function () {
                // Draw all links from hooks of this node
                var this_node = this;
                $.each(this.hooks, function (i, hook) {
                    if (hook.out && hook.to_node) {
                        var pt1, pt2;
                        pt1 = this_node.get_hook_center(hook);
                        if (hook.to_node.type == 'end_point') {
                            pt2 = hook.to_node.getCenterPoint();
                        } else {
                            pt2 = hook.to_node.get_hook_center('in');
                        }
                        canvas.remove(hook.path);
                        var svg_path = this_node.make_svg_path(pt1, pt2);
                        var new_path = new fabric.Path(svg_path, {
                            fill: null,
                            stroke: 'green',
                            opacity: 0.5,
                            strokeWidth: 2,
                            selectable: false,
                            hoverCursor: 'default'
                        });
                        hook.path = new_path;
                        canvas.add(new_path);
                        new_path.sendToBack();
                    }
                });
            },


            node_mouse_down: function (option) {
                console.log('node_mouse_down' + option.target.caption);

                var target = option.target;
                if (option.subTargets && option.subTargets.length > 0) {
                    var inner_target = option.subTargets[0];
                    if (inner_target.type == 'hook-bullet') {
                        var hook_bullet = inner_target;
                        var hook = hook_bullet.hook;
                        console.log(hook)
                        var pt1 = this.get_hook_center(hook);

                        var end_point = new fabric.Circle({
                            type: 'end_point',
                            name: 'end_point',
                            originX: 'center',
                            originY: 'center',
                            top: pt1.y + 5,
                            left: pt1.x + 25,
                            radius: 5,
                            fill: 'grey',
                            hasControls: false,
                            hasBorders: false,
                            from_hook: hook,
                            from_node: target,
                            hoverCursor: 'default',

                            // stroke: 'red',
                            // strokeWidth: 2
                        });

                        canvas.add(end_point);
                        hook.to_node = end_point;
                        draw_all_links();
                    }
                }
            },


            make_svg_path: function (pt1, pt2) {
                var d = Math.max(Math.abs(pt2.x - pt1.x) * 0.8, 20);
                var svg_path = 'M ' + pt1.x + ' ' + pt1.y + ' C ' + (pt1.x + d) + ' ' + pt1.y + ' ' + (pt2.x - d) + ' ' + pt2.y + ' ' + pt2.x + ' ' + pt2.y;
                return svg_path;
            },


            toJSON: function () {
               return {
                 id: this.id,
                 caption: this.caption,
                 text: this.text,
                  top: this.top,
                  left: this.left,
                  hooks_data: this.hooks_data,
               }
                // return fabric.util.object.extend(this.callSuper('toObject'), {
                //     customAttribute: this.get('customAttribute')
                // });
            },
            // Take from here: https://stackoverflow.com/questions/24384804/fabric-js-subclassing-fabric-group-error-cannot-read-property-async-of-und
            // fromObject: function (object, callback) {
            //     fabric.util.enlivenObjects(object.objects, function (enlivenedObjects) {
            //         delete object.objects;
            //         callback && callback(new fabric.Node(enlivenedObjects, object));
            //     });
            // }


        });
        /* Take from here: https://stackoverflow.com/questions/24384804/fabric-js-subclassing-fabric-group-error-cannot-read-property-async-of-und
        * Synchronous loaded object
        */
        fabric.Node.fromJSON = function (object, callback) {
          return new fabric.Node(object);
        };


        var nn1 = new fabric.Node({
            id:  '#34',
            caption: '#34',
            text: 'De quelle couleur sont les tomates ?',
            top: 150,
            left: 150,
            hooks_data: [
                {
                    "id": "in",
                    "caption": "in",
                    "type": "question-in",
                    "in": true,
                    "out": false,
                    "side": "left",
                    "align": "top",
                    "fill": "#888",
                    "size": 6
                },
                {
                    "id": "A",
                    "caption": "A",
                    "type": "question-out",
                    "in": false,
                    "out": true,
                    "side": "right",
                    "align": "top",
                    "fill": "#ddd",
                    "size": 5
                },
                {
                    "id": "B",
                    "caption": "B",
                    "type": "question-out",
                    "in": false,
                    "out": true,
                    "side": "right",
                    "align": "top",
                    "fill": "#ddd",
                    "size": 5
                },
                {
                    "id": "C",
                    "caption": "C",
                    "type": "question-out",
                    "in": false,
                    "out": true,
                    "side": "right",
                    "align": "top",
                    "fill": "#ddd",
                    "size": 5
                }
            ]
        });
        nn1.add_hook({
                "id": "D",
                "caption": "D",
                "type": "question-out",
                "in": false,
                "out": true,
                "side": "right",
                "align": "top",
                "fill": "rgba(250,250,0,0.5)",
                "size": 5
            }
        );
        nn1.add_hook({
                "id": "E",
                "caption": "E",
                "type": "question-out",
                "in": false,
                "out": true,
                "side": "right",
                "align": "top",
                "fill": "rgba(250,250,0,0.5)",
                "size": 5
            }
        );



        canvas.add(nn1);


        var nn2 = new fabric.Node({
            id:  '#38',
            caption: '#38',
            text: 'De quelle couleur sont les tomates ?',
            top: 150,
            left: 250,
            hooks_data: []
        });

        nn2.add_hook({
                "id": "in",
                "caption": "in",
                "type": "question-out",
                "in": true,
                "out": false,
                "side": "left",
                "align": "top",
                "fill": "rgba(250,250,0,0.5)",
                "size": 5
            }
        );
        nn2.add_hook({
                "id": "out",
                "caption": "out",
                "type": "question-out",
                "in": false,
                "out": true,
                "side": "right",
                "align": "top",
                "fill": "rgba(250,250,0,0.5)",
                "size": 5
            }
        );

        canvas.add(nn2);



        canvas.on('object:moved', function (options) {
            // console.log('object:moved ' + options.target.type);
            draw_all_links();

            if (options.target.type == 'end_point') {
                // check if connection is done
                var end_point = options.target;
                var end_point_center = options.target.getCenterPoint();


                for (node_id in all_nodes) {
                    var node = all_nodes[node_id];
                    var in_hook_center = node.get_hook_center('in');
                    if (Math.abs(in_hook_center.x - end_point_center.x) < 10 && Math.abs(in_hook_center.y - end_point_center.y) < 10) {
                        console.log('CONNECT TO ' + node.caption);
                        var from_node = end_point.from_node;
                        var from_hook = end_point.from_hook;
                        from_hook.to_node = node;
                        canvas.remove(end_point);
                        console.log(from_hook);
                        edge = {
                          'source': {'node_id': from_node.id,
                                      'hook_id': from_hook.id

                          },
                          'target': {'node_id': node.id,
                                    'hook_id': node.getHookById('in')

                          },

                        };
                        console.log(edge);
                        console.log(from_node);
                        break;
                    }
                }
            }
        });

        canvas.on('object:moving', draw_all_links);


        canvas.on('mousedown', function (options) {
            console.log('mouse:down ' + options.target.type);
            var coords = options.target.getLocalPointer();
            var x_abs = coords.x / options.target.scaleX;
            var y_abs = coords.y / options.target.scaleY;
            console.log('coordinates ' + x_abs + ', ' + y_abs);

        });


        function onMouseDown(options) {
            console.log('mouseDown ' + options.target.caption);

            if (options.subTargets) {
                var hook = options.subTargets[0];
                if (hook.type == 'hook') {
                    hook.bullet.set('fill', hook.selected ? '#888' : 'red');
                    hook.selected = !hook.selected;
                    canvas.renderAll();
                }
            }

        }


        function draw_all_links() {

            for (node_id in all_nodes) {
                all_nodes[node_id].draw_links();
            }

        }


        var bullet_a = nn1.get_hook_center('A');
        console.log('hook center: ' + bullet_a.x + ', ' + bullet_a.y);


        draw_all_links();

        nn1JSON = nn1.toJSON();
        console.log('nn1 to Object: ', nn1JSON);
        // update id
        nn1JSON['id'] = nn1JSON['id'] + 'COPY';
        nn1COPY = fabric.Node.fromJSON(nn1JSON);
        canvas.add(nn1COPY);


    })();

    </script>

</div>


<script>
    (function () {
        fabric.util.addListener(fabric.window, 'load', function () {
            var canvas = this.__canvas || this.canvas,
                canvases = this.__canvases || this.canvases;

            canvas && canvas.calcOffset && canvas.calcOffset();

            if (canvases && canvases.length) {
                for (var i = 0, len = canvases.length; i < len; i++) {
                    canvases[i].calcOffset();
                }
            }
        });
    })();
</script>


</body>
</html>
